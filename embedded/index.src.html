<h1>Content Security Policy: Embedded Enforcement</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec-csp/embedded/
TR: https://www.w3.org/TR/csp-embedded-enforcement/
Previous Version: https://www.w3.org/TR/2015/WD-csp-embedded-enforcement-20160909/
Shortname: csp-embedded-enforcement
Level: None
Editor: Mike West 56384, Google Inc., mkwst@google.com
Group: webappsec
Abstract:
  This document defines a mechanism by which a web page can embed a nested
  browsing context if and only if it agrees to enforce a particular set of
  restrictions upon itself.
Indent: 2
Version History: https://github.com/w3c/webappsec-csp/commits/master/embedded/index.src.html
Boilerplate: omit conformance, omit feedback-header
!Participate: <a href="https://github.com/w3c/webappsec-csp/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-csp/issues">open issues</a>)
Markup Shorthands: css off, markdown on
</pre>
<pre class="link-defaults">
spec:html; type:dfn; for:/; text:browsing context  
spec:html; type:dfn; text:case-sensitive
spec:html; type:dfn; text:ascii case-insensitive
spec:dom; type:interface; text:Document
spec:fetch
  type: dfn
    text:request; for: /
    text: response; for: /
spec:infra;
  type:dfn;
    text:string; for: /
    text:list; for: / 
    text:set; for: / 
    text:append; for: set
    text:empty; for: set
</pre>
<pre class="anchors">
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: grammar
    text: origin-or-null; url: http-origin
    text: wildcard; url: http-new-header-syntax
</pre>
<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  Introduction {#intro}
  ============

  <em>This section is not normative.</em>

  Content Security Policy is a great defense against cross-site scripting
  attacks, allowing developers to harden their own sites against injection of
  malicious script, style, and other resource types. It does not, however,
  give developers the ability to apply restrictions to third-party content
  loaded in via `<iframe>`. Allowing CSP to apply directly to these third-party
  contexts would be dangerous; CSP gives quite granular control over resource
  loading, and it's very possible to introduce vulnerabilities into an otherwise
  secure page by denying it access to particular scripts. We've seen these kinds
  of issues in past features such as `X-XSS-Protection`, so we must be careful
  to avoid reintroducing them in a new form.

  That said, it would be quite useful to be able to place restrictions upon
  widgets, advertisements, and other kinds of third-party content. This document
  proposes a mechanism which relies on an explicit opt-in from the embedded
  content, which ought to make it possible for widgets to cooperate with their
  embedders to negotiate a reasonable set of restrictions.

  In short, the embedder proposes a Content Security Policy as an attribute on
  the `<iframe>` element. This policy is transmitted along with the HTTP request
  for the framed content in an `Embedding-CSP` header. If the embedded content
  can accept that policy, it may do so by returning the proposed policy in a
  `Content-Security-Policy` header along with the response.

  If the response contains a policy identical to the policy which the embedder
  requested, the user agent will render the embedded content. If no such policy
  is present, the response will be blocked.

  Examples {#examples}
  --------

  <div class="example" id="example1">
    MegaCorp Inc. wishes to ensure that the advertisements that run on its
    various publications are locked down to include script from trusted origins
    that have been audited for safety. They can do so by including the
    advertisement via an <{iframe}> element with a <{iframe/csp}> attribute:

    <pre>
      &lt;iframe src="https://advertisements-r-us.example.com/ad1.cfm"
              <a for="iframe" element-attr>csp</a>="script-src https://trusted-cdn.example.com/"&gt;
      &lt;/iframe&gt;
    </pre>

    This will generate a request to `advertisements-r-us.example.com` that has
    an <a http-header>`Embedding-CSP`</a> header, as follows:

    <pre>
      GET / HTTP/1.1
      Host: advertisements-r-us.example.com
      ...
      <a http-header>Embedding-CSP</a>: script-src https://trusted-cdn.example.com/
      ...
    </pre>

    The advertisement server parses this request header, decides that it's
    acceptable, and reflects it in the response:

    <pre>
      HTTP/1.1 200 OK
      ...
      <a>Content-Security-Policy</a>: script-src https://trusted-cdn.example.com/
    </pre>

    Since the policy asserted by the response matches the policy required by the
    request, the frame loads successfully.
  </div>

  <div class="example" id="example2">
    The advertising server in the above example wishes to ensure that no plugins
    are loaded, regardless of what its embedder requires. It can do so by
    sending a restrictive policy in addition to any policy required by an
    embedder. That is, given a request that has an
    <a http-header>`Embedding-CSP`</a> header:

    <pre>
      GET / HTTP/1.1
      Host: advertisements-r-us.example.com
      ...
      <a http-header>Embedding-CSP</a>: script-src https://trusted-cdn.example.com/
      ...
    </pre>

    The advertisement server parses this request header, decides that it's
    acceptable, and reflects it in the response, along with a policy that
    prevents plugin loading:

    <pre>
      HTTP/1.1 200 OK
      ...
      <a>Content-Security-Policy</a>: script-src https://trusted-cdn.example.com/,
                               object-src 'none'
    </pre>
    
    The "`,`" in the <a>`Content-Security-Policy`</a> header's value splits the
    string into two serialized policies, each of which is enforced. The user
    agent verifies that one of the policies delivered with the response matches
    the requirement, and since additional policies can only make the
    <em>effective</em> policy for the page more restrictive, allows the frame
    to load successfully.
  </div>

  <div class="example" id="example3">
    To ease the embedee-side implementation, Advertisements-R-Us decides it can
    trust policies sent by MegaCorp, Inc. to be applied safely to its
    advertisements. It can express this assertion via the
    <a http-header>`Allow-CSP-From`</a> response header. Given the scenario in
    the above examples, the following response wold be loaded successfully:

    <pre>
      HTTP/1.1 200 OK
      ...
      <a http-header>Allow-CSP-From</a>: https://example.com/
    </pre>

    As would the wide-open response:

    <pre>
      HTTP/1.1 200 OK
      ...
      <a http-header>Allow-CSP-From</a>: *
    </pre>
  </div>
</section>

<section>
  Framework {#framework}
  =========

  Integration with HTML {#html-integration}
  ---------------------

  1.  <{iframe}> elements have a <dfn element-attr for="iframe">csp</dfn>
      attribute which specifies the policy that an embedded document must agree
      to enforce upon itself. Valid attribute values match the
      <a grammar>serialized-policy</a> grammar from [[!CSP3]].

      <pre class="idl">
        partial interface HTMLIFrameElement {
          [CEReactions] attribute DOMString csp;
        };
      </pre>

      {{HTMLIFrameElement}}'s {{HTMLIFrameElement/csp}} IDL attribute
      <a>reflects</a> the value of the element's <{iframe/csp}> content attribute.

      ISSUE: Upstream this to all the HTMLs.

  2.  A <a>browsing context</a> has a <dfn export>required CSP</dfn>, which is
      either `null` or a <a>serialized CSP</a>. For a given <a>browsing
      context</a> (|context|), the value is the result of executing
      [[#required-csp-for-context]] on |context|.

      ISSUE: Does this need to be upstreamed? Probably not.

  3.  Add the following to the list of error conditions in step 1 of HTML's
      <a>process a navigate response</a> algorithm:

      *   The [[#process-response]] algorithm returns "`Blocked`" when executed
          upon `response`, `request`, and `browsingContext`.

      ISSUE: Upstream this to WHATWG's HTML.

      ISSUE(w3c/html#584): W3C's HTML is not based on Fetch, and does not have
      a <a>process a navigate response</a> algorithm into which to hook.

  4.  Add the following after step 5 of HTML's <a>process a navigate fetch</a>
      algorithm:

      6.  If `browsingContext`'s <a>required CSP</a> is not `null`,
          <a for="header list">append</a> a header whose name is
          "<a http-header>`Embedding-CSP`</a>" and whose value is
          `browsingContext`'s <a>required CSP</a> to `request`'s
          <a for="request">header list</a>.

      ISSUE: Upstream this to WHATWG's HTML.

      ISSUE(w3c/html#584): W3C's HTML is not based on Fetch, and does not have
      a <a>process a navigate fetch</a> algorithm into which to hook.
  
  The `Embedding-CSP` HTTP Request Header {#embedding-csp-http-header}
  ---------------------------------------

  In order to ensure that the embedded resource can decide whether or not it is
  willing to adhere to the embedder's requirements, the policy expressed in an
  <{iframe}>'s <{iframe/csp}> attribute is communicated along with some
  <a>requests</a> via an "<dfn export http-header>`Embedding-CSP`</dfn>" HTTP
  request header. The header's value is represented by the following ABNF
  [[!RFC5234]]:

  <pre>
    Embedding-CSP = <a grammar>serialized-policy</a>
  </pre>

  A user agent MUST NOT send more than one HTTP response header field named
  "`Embedding-CSP`", and any such header MUST NOT contain more than one
  <a grammar>serialized-policy</a>.
  
  Servers MUST process only the first policy in the first such header received.

  The `Allow-CSP-From` HTTP Response Header {#allow-csp-from-http-header}
  -------------------------------------------

  An embedee can opt-into accepting a policy specified by an embedder by
  responding with a "<dfn export http-header>`Allow-CSP-From`</dfn>" HTTP
  response header. The header's value is represented by the following ABNF
  [[!RFC5234]]:

  <pre>
    Allow-CSP-From = <a grammar>origin-or-null</a> / <a grammar>wildcard</a>
  </pre>

  Policy Subsumption {#policy-subsumption}
  ------------------

  If an embedee does not wish to accept any <a>policy</a> specified by its 
  embedder via the <a http-header>Allow-CSP-From</a> header, it can deliver a
  <a>policy</a> that is as strict, or stricter than the policy requested in the
  <a http-header>Embedding-CSP</a> header. That is, if the embedder requests 
  `object-src https://cdn.example.com/`, the embedee can respond with 
  `object-src 'none'`. Because every possible <a>request</a> blocked by 
  `object-src https://cdn.example.com/` would also be blocked by 
  `object-src 'none'`, it is said that the embedder's required <a>policy</a> 
  <dfn>subsumes</dfn> the <a>policy</a> delivered by the embedee.

  Given the complexity of CSP's syntax, subsumption is not trivial to calculate.
  The details are spelled out in [[#subsume-policy-list].

</section>

<section>
  <h2 id="algorithms">Algorithms</h2>

  <h3 id="process-response" algorithm>
    Is |response| to |request| blocked by |context|'s required CSP?
  </h3>

  Given a <a>response</a> (|response|), a <a>request</a> (|request|), and a
  <a>browsing context</a> (|context|), this algorithm returns "`Allowed`" or
  "`Blocked`" as appropriate:

  <ol class="algorithm">
    1.  Return "`Allowed`" if either of the following is true:
    
        1.  |context| is not a <a>nested browsing context</a>.

        2.  |context|'s <a>required CSP</a> is `null`.

    2.  Let |embedding policy| be the result of executing
        [[csp3#parse-serialized-policy]] on |context|'s <a>required CSP</a> and
        "`enforce`".

    3.  If the [[#origin-allowed]] algorithm returns "`Allowed`" when executed upon
        |response| and |request|:

        1.  Append |embedding policy| to |response|'s <a for="response">CSP
            list</a>.

        2.  Return "`Allowed`".

    4.  Assert: |context| is a <a>nested browsing context</a>, and |response| is
        a cross-origin, <a>network schemed</a> resource.

    5.  If the [[#subsume-policy-list]] algorithm returns "`Subsumes`" when
        executed upon |embedding policy|, |request|'s <a for="request">origin</a>,
        |response|'s <a for="response">CSP list</a>, and |response|'s
        <a for="response">url</a>'s <a for="url">origin</a>, return "`Allowed`".

    6.  Return "`Blocked`".
  </ol>

  <h3 id="origin-allowed" algorithm>
    Does |response| allow blanket enforcment of policy from |request|?
  </h3>

  Given a <a>response</a> (|response|), and a <a>request</a> (|request|), this
  algorithm returns "`Allowed`" if the former allows the latter to enforce
  arbitrary policy, and "`Not Allowed`" otherwise:


  1.  If |response|'s <a for="response">url</a>'s <a for="url">scheme</a> is
      a <a>local scheme</a>, return "`Allowed`".

      Note: The embedder has direct access to same-origin responses, so if it
      wishes to enforce a policy on that same-origin response, we simply do so.
      
  2.  If |response|'s <a for="response">url</a>'s <a for="url">origin</a> is the
      same as |request|'s <a for="request">origin</a>, return "`Allowed`".

      Note: Likewise, <a>local scheme</a> responses already inherit their policy
      from the embedder, so we allow the embedder to tighten that policy via this
      embedding mechanism.

  3.  If |response|'s <a for="response">header list</a> has a header named
      <a http-header>`Allow-CSP-From`</a> (|header|):

      1.  If |header|'s value is "`*`", return "`Allowed`".

      2.  If |request|'s <a for="request">origin</a>,
          <a lt="ASCII serialization of an origin">serialized</a> and <a>UTF-8
          encoded</a> is |header|'s value, return "`Allowed`".

  4.  Return "`Not Allowed`".

  <h4 id="similarity-source-expressions" algorithm>
    Is an expression matching <a grammar>`scheme-source`</a> or 
    <a grammar>`host-source`</a> grammar |A| similar to an expression matching 
    <a grammar>`scheme-source`</a> or <a grammar>`host-source`</a> grammar |B|?
  </h4>

  Given two expressions matching the <a grammar>`scheme-source`</a>  or 
  <a grammar>`host-source`</a> grammar (|A| and |B|), return "`Similar`" if |A|
  is <a for="source expression">similar</a> to |B|. Otherwise, return 
  "`Not Similar`".

  |A| and |B| are said to be <dfn for="source expression">similar</dfn> if their
  parts individually match, that is <a grammar>`scheme-part`</a>, 
  <a grammar>`host-part`</a>, <a grammar>`port-part`</a>, and 
  <a grammar>`path-part`</a>. 

  NOTE: This property is symmetric. That is if |A| is 
  <a for="source expression">similar</a> to |B|, it must be that |B| is 
  <a for="source expression">similar</a> to |A|.

  <div class="example">
    Cases when |A| is <a for="source expression">similar</a> to |B|.

    <pre>
      A = https://inner.example.com/foo/
      B = http://*.example.com/foo/bar/
    </pre>
    Since |A| has a <a for="source expression">wildcard host</a>, it matches any
    subdomain which in this case is "inner" so that |A| is similar to |B|.

    <pre>
      A = http://*.example.com
      B = https://example.com:*
    </pre>
    Even though |A| and |B|'s ports are different, |A| and |B| are similar 
    because "http" matches both "http" and a more secure variant "https".

    <pre>
      A = http://example.com:80/page1/html
      B = https://example.com:443/
    </pre>
    In both sources specified ports are defalt ports for the respective schemes
    and |B|'s path would match any path, |A| is similar to |B|.


    Cases when |A| is not <a for="source expression">similar</a> to |B|.

    <pre>
      A = http://example.com:80
      B = http://example.com:334
    </pre>
    In this case, ports of |A| and |B| do not match so that the two sources are
    not <a for="source expression">similar</a> .

    <pre>
      A = http://example.com/page.html
      B = http://example.com/index.html
    </pre>
    The two sources are not <a for="source expression">similar</a> beucase their
    paths do not match.
  </div>

  A <a>source expression</a> has a 
  <dfn for="source expression">wildcard host</dfn> if the first character of the
  <a>source expression</a>'s <a grammar>`host-part`</a> is an U+002A ASTERISK 
  character (`*`).

  A <a>source expression</a> has a 
  <dfn for="source expression">wildcard port</dfn> if the 
  <a grammar>`port-part`</a> of the <a>source expression</a> is an U+002A 
  ASTERISK character (`*`).

  1.  Let |scheme A| be |A|'s <a grammar>`scheme-part`</a>, if present, and 
      `null` otherwise.
      
  2.  Let |scheme B| be |B|'s <a grammar>`scheme-part`</a>, if present, and 
      `null` otherwise.

  3.  If the result of executing [[csp3#match-schemes]] returns 
      "`Does Not Match`" given |scheme A| and |scheme B|, and the result of 
      executing [[csp3#match-schemes]] on |scheme B| and |scheme A| is 
      "`Does Not Match`", return "`Not Similar`".

  4.  If |A| or |B| matches  <a grammar>`scheme-source`</a> grammar,
      return "`Similar`".

  5.  Return "`Not Similar`" if any of the following is true:

      1.  Let |host A| be |A|'s <a grammar>`host-part`</a>, if present, and 
          `null` otherwise.
      
      2.  Let |host B| be |B|'s <a grammar>`host-part`</a>, if present, and 
          `null` otherwise.

      3.  Both |A| and |B| have a <a for="source expression">wildcard host</a>,
          but |host A| is not an <a>ASCII case-insensitive</a> match to |host B|.

      4.  At most one of |A| and |B| has a 
          <a for="source expression">wildcard host</a>, the result of executing 
          [[csp3#match-hosts]] is "`Does Not Match`" given |host A| and 
          |host B|, and the result of executing [[csp3#match-hosts]] on |host B|
          and |host A| is also "`Does Not Match`".

      5.  Let |port A| be |A|'s <a grammar>`port-part`</a>, if present, and 
          `null` otherwise.
      
      6.  Let |port B| be |B|'s <a grammar>`port-part`</a>, if present, and 
          `null` otherwise.

      7.  Neither |A| nor |B| has a <a for="source expression">wildcard port</a>,
          the result of executing [[csp3#match-ports]] is "`Does Not Match`"
          given |port A| and |port B|, and the result of executing 
          [[csp3#match-ports]] given |port B| and |port A| is also 
          "`Does Not Match`".

      8.  Let |path A| be |A|'s <a grammar>`path-part`</a>, if present, and 
          `null` otherwise.
      
      9.  Let |path B| be |B|'s <a grammar>`path-part`</a>, if present, and 
          `null` otherwise.

      10.  The result of executing [[csp3#match-paths]] is "`Does Not Match`"
           given |path A| and |path B| and the result of executing 
           [[csp3#match-paths]] given |path B| and |path A| is also 
           "`Does Not Match`".

  6.  Return "`Similar`".

  <h4 id="intersection-source-expressions" algorithm>
    What is an intersection of two expressions matching 
    <a grammar>`scheme-source`</a> or <a grammar>`host-source`</a> 
    grammar |A| and |B|?
  </h4>

  <a>Source expression</a> is said to be an 
  <dfn for="source expression">intersection</dfn> of two other 
  expressions matching <a grammar>`scheme-source`</a> or 
  <a grammar>`host-source`</a>  grammar |A| and |B| if it contains the more
  restrictive <a grammar>`scheme-part`</a>, <a grammar>`host-part`</a>, 
  <a grammar>`port-part`</a>, and <a grammar>`path-part`</a> of the two. 

  <div class="example">
    In these cases, `Intersect` is an 
    <a for="source expression">intersection</a> for |A| and |B|.
      
    <pre>
      A = https:
      B = http:
      Intersect = https:
    </pre>

    <pre>
      A = http://*.example.com
      B = https://example.com:*
      Intersect = https://example.com:443
    </pre>

    <pre>
      A = http://example.com:80/page1/html
      B = https://example.com:443/
      Intersect = https://example.com:443/page1/html
    </pre>

    <pre>
      A = https:
      B = http://example.com
      Intersect = `https://example.com`.
    </pre>

    <pre>
      A = https://example.com:*
      B = http://*.example.com/page.html
      Intersect = `https://example.com/page.html`
    </pre>
  </div>

  Given two expressions matching the <a grammar>`scheme-source`</a> or 
  <a grammar>`host-source`</a> grammar (|A| and |B|), return their 
  <a for="source expression">intersection</a> if |A| is 
  <a for="source expression">similar</a> to |B|. Otherwise, return `null`.

  1.  If the result of executing [[#similarity-source-expressions]] on |A| and 
      |B| is "`Not Similar`", return `null`.

  2.  Let |source| be an empty string.

  3.  Let |scheme A| be |A|'s <a grammar>`scheme-part`</a>, if present, and 
      `null` otherwise.
      
  4.  Let |scheme B| be |B|'s <a grammar>`scheme-part`</a>, if present, and 
      `null` otherwise.

  5.  Let |more secure scheme B| be `true` if the result of executing 
      [[csp3#match-schemes]] is "`Does Not match`" given |scheme A| and 
      |scheme B|, and `false` otherwise.

  6.  Append |scheme A| and ":" to |source| if |scheme A| is not `null` and 
      |more secure scheme B| is `false`. Otherwise, append |scheme B| and ":"
      to |source| if |scheme B| is not `null`.

  7.  If both |A| and |B| match the <a grammar>`scheme-source`</a> grammar,
      return |source|. 

  8.  Append "//" to |source| if it is not empty.

  9.  Let |host A| be |A|'s <a grammar>`host-part`</a>, if present, and 
      `null` otherwise.
      
  10.  Let |host B| be |B|'s <a grammar>`host-part`</a>, if present, and 
       `null` otherwise.

  11.  If |host A| is not `null`:

       1.  If |host B| is `null`, append |host A| to |source|.
           Continue to the next step in the main algorithm.

       2.  If |A| doesn't match the <a grammar>`scheme-source`</a> grammar and 
           doesn't have a <a for="source expression">wildcard host</a>, append 
           |host A| to |source|.

       3.  Otherwise, append |host B| to |source|.

  12.  If |host A| is `null`, append |host B| to |source|.

  13.  Let |port A| be |A|'s <a grammar>`port-part`</a>, if present, and 
       `null` otherwise.
      
  14.  Let |port B| be |B|'s <a grammar>`port-part`</a>, if present, and 
       `null` otherwise.

  15.  If |port A| is `null`, append ":" and |port B| to |source| if it is 
       not `null`. 

  16.  If |port A| is not `null`:

       1.  If |port B| is `null`, append ":" and |port A| to |source|.
           Continue to the next step in the main algorithm.

       2.  If |A| doesn't have a <a for="source expression">wildcard port</a> 
           and |more secure scheme B| is `false`, append ":" and |port A| 
           to |source|.
       
       3.  Otherwise, append ":" and |port B| to |source|.

  17.  Let |path A| be |A|'s <a grammar>`path-part`</a>, if present, and 
      `null` otherwise.
      
  18.  Let |path B| be |B|'s <a grammar>`path-part`</a>, if present, and 
      `null` otherwise.

  19.  If |path A| is `null`, append |path B| to |source| if it is not `null`. 

  20.  If |path A| is not `null`:

       1.  If |path B| is `null`, append |path A| to |source|.
           Continue to the next step in the main algorithm.

       2.  If the result of executing [[csp3#match-paths]] on |path A| and 
           |path B| is "`Does Not Match`", append |path A| to |source|.
       
       3.  Otherwise, append |path B| to |source|.

  21.  Return |source|.

  <h4 id="effective-source-list" algorithm>
    Get the effective <a>source list</a> for a <a>source list</a>,
    <a for="/">origin</a>, and <a for="directive">name</a>.
  </h4>

  An <dfn>effective source list</dfn> is a <a>list</a> which simplifies a given
  <a>source list</a> by removing any ineffective, obviated, or invalid
  <a>source expressions</a>, and expanding complex tokens like 
  <a grammar>'self'</a> or <a grammar>*</a> into a more easily comparable, 
  if more verbose, <a>list</a>.

  <div class="example">

    For any directive with origin `https://example.test/`:
    <pre>
      https: wss: 'none' 'self'
    </pre>
    The effective source list is "http: wss: https://example.test/". Note that
    "'none'" is not part of the effective source list because it has no effect
    when it is not the only source.

    For "`style-src`":
    <pre>
      http://example.com 'strict-dynamic' 'nonce-abc'
    </pre>
    The effective source list is "http://example.com 'nonce-abc'" since
    "'strict-dynamic'" is ignored in non-"`script-src`" directives.

    For "`script-src`":
    <pre>
      http://example.com 'strict-dynamic' 'nonce-abc'
    </pre>
    The effective source list is "'strict-dynamic' 'nonce-abc'" since
    "'strict-dynamic'" in "`script-src`" case does not honor host and scheme
    source expressions.
  </div>

  Given a <a>source list</a> (|source list|), <a for="request">origin</a>
  (|origin|), and string (|directive|), the following algorithm returns a
  an <a for="source list">effective</a> <a>source list</a> for |source list|.

  1.  If |source list| <a for="set">is empty</a> or « 'none' »,
      return « 'none' ».

  2.  If |source list| <a for="set">contains</a> a token that is an
      <a>ASCII case-insensitive</a> match to the <a grammar>`keyword-source`</a>
      "<a grammar>`'self'`</a>":

      1.  Remove that token from |source list|.

      2.  <a for="set">Append</a> the result of executing [[#rewrite-self]]
          given |origin| to |source list|.

  3.  Let |effective| be an empty <a>source list</a>.

  4.  If |directive| is "`plugin-types`":

      1.  For each |expression| in |source list|:

          1.  If |expression| does not match <a grammar>`media-type`</a>,
              <a for="iteration">continue</a>.

          2.  <a for="set">Append</a> |expression| to |effective|.

      2.  If |effective| <a for="set">is empty</a>, return « 'none' ». 

      3.  Return |effective|.

  5.  For each |expression| in |source list|:

      1.  If |expression| matches <a grammar>`keyword-source`</a> grammar
          and |directive| is not "`script-src`" or "`style-src`",
          <a for="iteration">continue</a>.

      2.  If |directive| is "`script-src`" and |source list|
          <a for="set">contains</a> a token that is an
          <a>ASCII case-insensitive</a> match to the
          <a grammar>`keyword-source`</a> "<a grammar>`'strict-dynamic'`</a>":

          1.  If |expression| matches <a grammar>`host-source`</a>, 
              <a grammar>`scheme-source`</a> grammar or
              <a grammar>`keyword-source`</a>
              "<a grammar>`'unsafe-inline'`</a>",
              <a for="iteration">continue</a>.

      3.  If |expression| is an <a>ASCII case-insensitive</a> match to the
          <a grammar>`keyword-source`</a> "<a grammar>`'strict-dynamic'`</a>"
          and |directive| is not "`script-src`",
          <a for="iteration">continue</a>.

      4.  If |directive| is "`frame-ancestors`" and |expression| matches 
          <a grammar>`nonce-source`</a> or <a grammar>`hash-source`</a> grammar, 
          <a for="iteration">continue</a>.

      5.  If |expression| is an <a>ASCII case-insensitive</a> match to 
          "<a grammar>`'none'`</a>", <a for="iteration">continue</a>.

      6.  If |expression| matches the U+002A ASTERISK character (`*`):

          1.  Append to |effective| the following <a grammar>`scheme-source`</a>
              expressions: "`ftp:`", "`http:`", "`https:`", "`ws:`", "`wss:`",
              and |origin|'s <a for="origin">scheme</a>.

          2.  <a for="iteration">Continue</a>. 

      7.  <a for="set">Append</a> |expression| to |effective|.

  6.  If |effective| <a for="set">is empty</a>, return « 'none' ». 

  7.  If |effective| is « 'strict-dynamic' », return « 'none' ». 

  8.  Return |effective|.

  <h4 id="intersection-source-lists" algorithm>
    What is an intersection of two <a>source lists</a>  
    |A| and |B| given their respective <a for="/">origins</a>
    and directive names?
  </h4>

  The <dfn for="source list">intersection</dfn> of two <a>source lists</a>
  is a <a>source list</a> which <a for="list">contains</a> every
  <a>source expression</a> <a>subsumed</a> by both. If no such 
  <a>source expressions</a> exist (because, for example, one of the lists
  contains only <a grammar>'none'</a>), then the 
  <a for="source list">intersection</a> will be the list 
  « <a grammar>'none'</a> ».

  <div class="example">
    In these cases, `intersection` is an 
    <a for="source expression">intersection</a> for |A| and |B|.
      
    <pre>
      A = wss: http://example.com
      B = https: wss: 'none'
      intersection = wss: https://example.com
    </pre>
    The expression "wss:" is present in both policies, so it is present in
    their intersection. Similarly, "http://example.com" is present in the
    intersection because it is the only expression subsumed by both
    "http://example.com" and "https:". Note that "'none'"" is ignored, as it is
    not the only token in |B|.

    <pre>
      A = http://*.a.com http://*.b.com
      B = https://a.com:* http://*.c.com
      intersection = https://a.com
    </pre>
    Only two sources are similar: "http://*.a.com" in |A| is similar to 
    "https://a.com:*" in |B| so the intersection of the two source lists is
    "https://a.com".

    <pre>
      A = 'unsafe-inline' http://example.com:443/page1/html 'nonce-abc'
      B = 'unsafe-inline' https://example.com:443/ 'strict-dynamic' 'nonce-abc'
      intersection = 'nonce-abc'
    </pre>
    Since "`strict-dynamic`" honors only <a grammar>`nonce-source`</a> and
    <a grammar>`hash-source`</a> expressions, |B| is effectively 
    "'strict-dynamic' 'nonce-abc'". That is why the |intersection| is 
    "'nonce-abc'".
  </div>

  Given a <a>source list</a> |A|, <a for="/">origin</a> (|origin A|)
  <a>string</a> (|directive A|), <a>source list</a> |B|,
  <a for="/">origin</a> (|origin B|) and <a>string</a> (|directive B|),
  this algorithm returns a <a>source list</a> that is an 
  <a for="source list">intersection</a> of |A| and |B|.

  1.  If |directive A| is not an <a>ASCII case-insensitive</a> match to 
      |directive B|, return « 'none' ».

  2.  Let |effective A| be the result of executing [[#effective-source-list]]
      given |A|, |origin A|, and |directive A|.

  3.  Let |effective B| be the result of executing [[#effective-source-list]]
      given |B|, |origin B|, and |directive B|.

  4.  If either |effective A| or |effective B| is  « 'none' », 
      return « 'none' ».

  5.  If |effective A| is empty, return |effective B|.

  6.  If |effective B| is empty, return |effective A|.

  7.  Let |schemes A| and |schemes| be empty <a>lists</a>.

  8.  For each |expression A| in |effective A|:

      1.  If |expression A| matches <a grammar>`scheme-source`</a> grammar:

          1.  <a for="list">Append</a> |expression A| to |schemes A|.

          2.  If |expression A| matches "`http:`", <a for="list">append</a>
              "`https:`" to |schemes A|.

          3.  If |expression A| matches "`ws:`", <a for="list">append</a>
              "`wss:`" to |schemes A|.

  9.  For each |expression B| in |effective B|:

      1.  If |expression B| matches <a grammar>`scheme-source`</a> grammar
          and |expression B| matches one of the elements in |schemes A|:

          1.  <a for="list">Append</a> |expression B| to |schemes|.

          2.  If |expression B| matches "`http:`" and |schemes A|
              <a for="list">contains</a> "`https:`", <a for="list">append</a>
              "`https:`" to |schemes|.

          3.  If |expression B| matches "`ws:`" and |schemes A|
              <a for="list">contains</a> "`wss:`", <a for="list">append</a>
              "`wss:`" to |schemes|.

  10.  Let |intersection| be an empty <a>source list</a>.

  11.  For each |expression| in |schemes|:

       1.  If |expression| does not match "`https:`" or |schemes| does not
           <a for="list">contain</a> "`http:`":

           1.  If |expression| does not match "`wss:`" or |schemes| does not
               <a for="list">contain</a> "`ws:`", <a for="set">append</a>
               |expression| to |intersection|.

  12.  For each |expression A| in |effective A|:

      1.  If |expression A| matches <a grammar>`scheme-source`</a> grammar
          and |schemes| <a for="list">contains</a> |expression A|,
          <a for="iteration">continue</a>.

      2.  Let |match| be `null`.

      3.  For each |expression B| in |effective B|:

          1.  If at least one of |expression A| and |expression B| does not
              match <a grammar>`scheme-source`</a> or
              <a grammar>`host-source`</a> grammar:

              1.  If |expression A| matches <a grammar>`keyword-source`</a>
                  grammar and is an <a>ASCII case-insensitive</a> match for
                  |expression B|, <a for="set">append</a> |expression A| to
                  |intersection|.

              2.  If |expression A| matches <a grammar>`nonce-source`</a> or
                  <a grammar>`hash-source`</a> grammar and is a
                  <a>case-sensitive</a> match for |expression B|, 
                  <a for="set">append</a> |expression A| to |intersection|.

              3.  <a for="iteration">Continue</a> to the next |expression B|.

          2.  If |expression B|'s <a grammar>`scheme-part`</a> matches one of
              the elements in |schemes|, <a for="iteration">continue</a> to the
              next |expression B|.

          3.  If |expression A| matches <a grammar>`scheme-source`</a> grammar:

              1.  If |expression B| matches <a grammar>`host-source`</a> grammar
                  and the result of executing
                  [[#intersection-source-expressions]] is not `null` given
                  |expression A| and |expression B|, <a for="set">append</a> the
                  result to |intersection|. 

              2.  <a for="iteration">Continue</a> to the next |expression B|.

          4.  If the result of executing [[#subsume-source-list]] is
              "`Subsumes`" given |expression B| and |expression A|,
              <a for="set">append</a> |expression A| to |intersection|.
              <a for="iteration">Continue</a> to the next |expression A|.

          5.  If the result of executing [[#intersection-source-expressions]] is
              not `null` given |expression A| and |expression B|, set |match| to
              the result.

      4.  If |match| is not `null`, <a for="set">append</a> |match| to
          |intersection|.

  13.  Return |intersection|.
 
  <h4 id="rewrite-self" algorithm>
    Rewrite `'self'` into a host-source expression for |origin|.
  </h4>

  Given an origin (|origin|), this algorithm returns a
  <a grammar>`host-source`</a> expression that has the same effect
  as `'self'` for that origin:

  1.  If |origin| is an <a>opaque origin</a>, return the empty string.

  2.  Return the  <a lt="ascii serialization of an origin">ASCII 
      serialization</a> of |origin|.

  <h4 id="subsume-source-expressions" algorithm>
    Does `source expression` |A| subsume `source expression` |B|?
  </h4>

  Given two <a>source expressions</a> |A| and |B|, this algorithm returns 
  "`Subsumes`" if |A| <a>subsumes</a> |B|, and returns "`Does Not Subsume`"
  otherwise.

  1.  Assert: Neither |A| nor |B| match the <a grammar>`keyword-source`</a>
      grammar.

  2.  If both |A| and |B| match either <a grammar>`host-source`</a> or 
      <a grammar>`scheme-source`</a> grammar:

      1.  If [[csp3#match-schemes]] returns "`Does Not Match`" given |A|'s 
          <a grammar>`scheme-part`</a> (or `null` if |A| does not contain a 
          <a grammar>`scheme-part`</a>) and |B|'s <a grammar>`scheme-part`</a> 
          (or `null` if |B| does not contain a <a grammar>`scheme-part`</a>), 
          return "`Does Not Subsume`".

      2.  If |A| or |B| matches the <a grammar>`scheme-source`</a> grammar:

          1.  If |A| matches the <a grammar>`scheme-source`</a> grammar, return 
              "`Subsumes`". Otherwise, return "`Does Not Subsume`".

      3.  If |B| has a `wildcard host`:

          1.  If |A| doesn't have a `wildcard host`, return "`Does not Subsume`".

          2.  Let |remaining host B| be the result of removing the leading 
              ("*.") from |B|'s <a grammar>`host-part`</a>.

          3.  If [[csp3#match-hosts]] returns "`Does Not Match`" given |A|'s 
              <a grammar>`host-part`</a> and |remaining host B|, return 
              "`Does Not Subsume`".

      3.  If |B| doesn't have a `wildcard host` and [[csp3#match-hosts]] returns 
          "`Does Not Match`" given |A|'s  <a grammar>`host-part`</a> and |B|'s 
          <a grammar>`host-part`</a>, return "`Does Not Subsume`".

      4.  If |A| has a `wildcard port` but |B| doesn't have a `wildcard port`, 
          return "`Does Not Subsume`".

      5.  If |A| doesn't have a `wildcard port` and [[csp3#match-ports]] returns
          "`Does Not Match`" given |A|'s <a grammar>`port-part`</a> 
          (or `null` if |A| does not contain a <a grammar>`port-part`</a>)
          and |B|'s <a grammar>`port-part`</a> (or `null` if |B| does not 
          contain a <a grammar>`port-part`</a>), return "`Does Not Subsume`".

      6.  If [[csp3#match-paths]] returns "`Does Not Match`" given |A|'s 
          <a grammar>`path-part`</a> (or `null` if |A| does not contain a 
          <a grammar>`path-part`</a>) and |B|'s <a grammar>`path-part`</a> (or 
          `null` if |B| does not contain a <a grammar>`path-part`</a>), return 
          "`Does Not Subsume`".

      7.  Return "`Subsumes`".

  3.  If both |A| and |B| match the <a grammar>`hash-source`</a> grammar:

      1.  If |A| is a <a>case-sensitive</a> match to |B|, return "`Subsumes`". 
          Otherwise, return "`Does Not Subsume`".

  4.  If both |A| and |B| match the <a grammar>`nonce-source`</a> grammar:

      1.  ISSUE: TODO.

  5.  Return "`Does Not Subsume`".

  <h4 id="intersection-policies" algorithm>
    What is an intersection of two <a>policy</a> objects |A| and |B|
    given their respective <a for="request">origins</a>?
  </h4>

  <a>Policy</a> (|Intersection|) is said to be an 
  <dfn for="policy">intersection</dfn> of two <a>policy</a> objects |A| and |B|
  if both |A| and |B| <a>subsume</a> |Intersection|.

  <div class="example">
    In these cases, `Intersection` is an 
    <a for="source expression">intersection</a> for |A| and |B|.
      
    <pre>
      A = default-src 'self' http://example.com http://example.net;
         connect-src 'none';
      B = connect-src http://example.com/; script-src http://example.com/

      Intersection = default-src 'self' http://example.com http://example.net;
                     connect-src 'none'; script-src http://example.com/;
    </pre>
    Both |A| and |B| <a>subsume</a> |Intersection|.
    For example, |Intersection|'s "script-src http://example.com/" is
    <a>subsumed</a> by the first policy's
    "default-src 'self' http://example.com http://example.net" and second policy's
    "script-src http://example.com/".
  </div>

  Given a <a>policy</a> object |A|, an <a for="request">origin</a> (|origin A|),
  a <a>policy</a> object |B|, and an <a for="request">origin</a> (|origin B|),
  this algorithm returns a <a>policy</a> that is an
  <a for="policy">intersection</a> of |A| and |B|.

  1.  If |A|'s <a>directive set</a> <a for="list">is empty</a> or its
      <a for="policy">disposition</a> is "`report`", return |B|.

  2.  If |B|'s <a>directive set</a> <a for="list">is empty</a> or its
      <a for="policy">disposition</a> is "`report`", return |A|.

  3.  Let |policy| be a new <a for="/">policy</a> with an empty
      <a for="policy">directive set</a>, and a <a for="policy">disposition</a>
      "`enforce`".

  4.  Let |names| be a <a>list</a> containing the <a for="directive">name</a> of
      each <a>directive</a> contained in either |A| or |B|.

  5.  For each |directive name| in |names|:

      1.  If |directive name| is "`report-uri`", "`report-to`",
          <a for="iteration">continue</a> to the next |directive name|.

      2.  Let |directive A| be the result of executing
          [[#operative-directive]] given |directive name| and |A|.

      3.  Let |directive B| be the result of executing
          [[#operative-directive]] given |directive name| and |B|.

      4.  If both |directive A| and |directive B| are `null`, 
          <a for="iteration">continue</a> to the next |directive name|.

      5.  If |directive A| is `null`, <a for="set">append</a> a new
          <a>directive</a> with |directive name| and |directive B|'s
          <a for="directive">value</a>, to |policy|'s <a>directive set</a>.
          <a for="iteration">Continue</a> to the next |directive name|.

      6.  If |directive B| is `null`, <a for="set">append</a> a new
          <a>directive</a> with |directive name| and |directive A|'s
          <a for="directive">value</a>, to |policy|'s <a>directive set</a>.
          <a for="iteration">Continue</a> to the next |directive name|.

      7.  Let |directive value| be the result of executing
          [[#"intersection-source-lists"]] given |directive A|'s
          <a for="directive">value</a>, |origin A|, |directive name|,
          |directive B|'s <a for="directive">value</a>, |origin B|, and
          |directive name|.

      8.  Let |directive| be a new <a>directive</a> with |directive name|
          and |directive value|.

      9.  <a for="set">Append</a> |directive| to |policy|'s
          <a>directive set</a>.

  6.  Return |policy|.

  <h4 id="intersection-policy-list" algorithm>
    What is an intersection of a |policy list| for an
    <a for="/">origin</a>?
  </h4>

  The <dfn for="policy">intersection</dfn> of a <a>list</a> of <a>policy</a> 
  objects is a single <a>policy</a> which is <a>subsumed</a> by each item in
  the list. In other words, the <a for="policy">intersection</a> of multiple
  <a>policy</a> objects represents the effective policy created when each of
  those policy object is applied to a single context (see 
  [[csp3#multiple-policies]] for more detail).

  <div class="example">
    In these cases, `Intersection` is an 
    <a for="source expression">intersection</a> for |A| and |B|.
      
    <pre>
      Content-Security-Policy: default-src 'self' http://example.com http://example.net;
                               connect-src 'none';
      Content-Security-Policy: connect-src http://example.com/;
                               script-src http://example.com/
      Content-Security-Policy: style-src 'self';
                               script-src http://example.com/ http://example.net

      Intersection: default-src 'self' http://example.com http://example.net;
                    connect-src 'none';
                    script-src http://example.com/;
                    style-src 'self'
    </pre>
    Each |policy| specified in |policy list| <a>subsumes</a> |intersection|.
  </div>

  Given a list of <a>policy</a> objects (|policy list|) and an
  <a for="/">origin</a> (|origin|), this algorithm returns a <a>policy</a>
  that is an <a for="policy">intersection</a> for the given list.

  1.  If |policy list| <a for="list">is empty</a>, return a 
      <a for="/">policy</a> object with an empty <a>directive set</a> and 
      disposition "`enforce`".

  2.  Let |intersection| be the first element in |policy list| with disposition
      "`enforce`". If there is no such element, return a 
      <a for="/">policy</a> object with an empty <a>directive set</a> and 
      disposition "`enforce`".

  3.  If |policy list|'s size is one, return |current|.

  4.  For each |policy| in |policy list|:

      1.  If |policy|'s <a for="policy">disposition</a> is "`report`",
          <a for="iteration">continue</a> to the next |policy|.

      2.  Let |result| be the result of executing [[#intersect-policies]]
          given |intersection|, |origin|, |policy| and |origin|.

      3.  Set |intersection| to |result|.

  5.  Return |intersection|.

  <h4 id="subsume-source-list" algorithm>
    Does <a>source list</a> |A| subsume <a>source list</a>|B| given their
    respective <a for="request">origins</a> and directive names?
  </h4>

  Given a <a>source list</a> |A| with an <a for="request">origin</a>
  (|origin A|) and a string (|directive A|), <a>source list</a> |B| with an
  <a for="request">origin</a> (|origin B|) and a string (|directive B|), this
  algorithm returns "`Subsumes`" if |A| <a>subsumes</a> |B|, and returns 
  "`Does Not Subsume`" otherwise.

  A <a>directive</a> <dfn for="directive">contains</dfn> a given
  <a>source expression</a> if the expression is <a for="list">contained</a> by
  its <a for="directive">value</a>.

  1.  If |directive A| is not an <a>ASCII case-insensitive</a> match to 
      |directive B|, return "`Does Not Subsume`".

  2.  If |A| is empty or |B| is `none`, return "`Subsumes`".

  3.  If |B| is empty or |A| is `none`, return "`Does Not Subsume`".

  4.  If |directive B| is "`script-src`" and |B| <a for="directive">contains</a>
      a <a grammar>`keyword-source`</a> expression "`strict-dynamic`" but |A|
      does not contain it, return "`Does Not Subsume`".

  5.  If |directive B| is "`script-src`" or "`style-src`":

      1.  If |B| <a for="directive">contains</a> a
          <a grammar>`keyword-source`</a> expression "`unsafe-eval`" but |A|
          does not contain it, return "`Does Not Subsume`".

      2.  If |B| <a for="directive">contains</a> a
          <a grammar>`keyword-source`</a> expression
          "`unsafe-hashed-attributes`" but |A| does not contain it, return
          "`Does Not Subsume`".

      3.  Let |type B| be "`script`" if |directive B| is "`script-src`" and 
          "`style`" otherwise. Similarly, let |type A| be "`script`" if 
          |directive A| is "`script-src`" and "`style`" otherwise.

      4.  If [[csp3#allow-all-inline]] returns "`Allows`" given |B| with 
          |type B|, but returns "`Does Not Allow`" given |A| with 
          |type A|, return "`Does Not Subsume`".

  6.  Let |list A| and |list B| be empty lists.

  7.  For each |expression A| in |A|:

      1.  If |expression A| is "`self`", append a <a grammar>`host-source`</a>,
          returned by [[#rewrite-self]] given |origin A| to |list A|.

      2.  If |expression A| matches the U+002A ASTERISK character (`*`),
           append to |list A| the following <a grammar>`scheme-source`</a>
           expressions: "`ftp:`", "`http:`", "`https:`", "`ws:`", "`wss:`",
           and |origin A|'s <a for="origin">scheme</a>.
           
           1.  If |directive A| is either "`img-src`" or "`media-src", append a 
               <a grammar>`scheme-source`</a> expression "`data:`" to |list A|.
           
           2.  If |directive A| is "`media-src", append a 
               <a grammar>`scheme-source`</a> expression "`blob:`" to |list A|.

           3.  <a for="iteration">Continue</a> to the next |expression A|. 

       3.  If |expression A| does not match <a grammar>`keyword-source`</a>
           grammar, append |expression A| to |list A|.

  8.  For each |expression B| in |B|:

      1.  If |expression B| is "`self`", append a <a grammar>`host-source`</a>,
          returned by [[#rewrite-self]] given |origin B| to |list B|.

      2.  If |expression B| matches the U+002A ASTERISK character (`*`),
          append to |list B| the following <a grammar>`scheme-source`</a>
          expressions: "`ftp:`", "`http:`", "`https:`", "`ws:`", "`wss:`",
          and |origin B|'s <a for="origin">scheme</a>.

          1.  If |directive B| is either "`img-src`" or "`media-src", append a 
              <a grammar>`scheme-source`</a> expression "`data:`" to |list B|.
           
          2.  If |directive B| is "`media-src", append a 
              <a grammar>`scheme-source`</a> expression "`blob:`" to |list B|.

          3.  <a for="iteration">Continue</a> to the next |expression B|. 

      3.  If |expression B| does not match <a grammar>`keyword-source`</a>
          grammar, append |expression B| to |list B|.

  9.  If |list B| is empty, return "`Subsumes`".

  10.  If |list A| is empty, return "`Does Not Subsume`".

  11.  For each |expression B| in |list B|:

      1.  If |expression B| matches the <a grammar>`hash-source`</a> gramar, or
          <a grammar>`nonce-source`</a> grammar, <a for="iteration">continue</a>
          to the next expression unless |directive A| is "`script-src`" or
          "`style-src`".

      2.  Let |found match| be `false`.

      3.  For each |expression A| in |list A|:

          1.  If [[#subsume-source-expressions]] returns "`Subsumes`" given
              |expression A| and |expression B|, set |found match| to `true`.
              Break out of this inner loop.

      4.  If |found match| is `false`, return "`Does Not Subsume`".

  12.  Return "`Subsumes`".

  <div class="example">
    Let |directive A| and |directive B| be "`script-src`". Consider
    the following examples:

    <pre>
      A = "http://example.com 'sha256-xzi4zkCjuC8'"
      B = "http://example.com"
    </pre>
    Since |B| does not allow <a grammar>`hash-source`</a> expressions, but its
    value is found in |A|, |A| subsumes |B|. It is, however, not true that |A|
    <a>subsumes</a> |B|.

    <pre>
      A = "https://example.com 'sha256-xzi4zkCjuC8'"
      B = "http://example.com"
    </pre>
    In this case, |A| does not subsume |B| since "https://example.com" does
    not <a>subsume</a> "http://example.com".

    <pre>
      A = "http://example.com 'sha256-xzi4zkCjuC8'"
      B = "http://example.com 'unsafe-inline'"
    </pre>
    Since |B| <a lt="allow all inline behavior" for="source list">allows all inline behavior</a>, 
    but |A| does not, |A| doesn't <a>subsume</a> |B|. 

    <pre>
      A = "http://example.com 'sha256-xzi4zkCjuC8' 'strict-dynamic'"
      B = "http://example.com 'unsafe-inline' 'strict-dynamic'"
    </pre>
    Neither |A| nor |B| <a for="source list">allow all inline behavior</a>.
    In this case, |A| <a>subsumes</a> |B|.
  </div>

  <h4 id="effective-directive" algorithm>
    Get the effective directive value for |name| and |policy|.
  </h4>

  Given a string (|name|) and <a>policy</a> (|policy|), the following algorithm
  returns either `null` or a set of non-empty strings.

  1.  Switch on |name|'s and execute the associated steps:

      : "`child-src`"
      ::

      : "`connect-src`"
      ::

      : "`font-src`"
      ::

      : "`img-src`"
      ::

      : "`manifest-src`"
      ::

      : "`media-src`"
      ::

      : "`object-src`"
      ::

      : "`script-src`"
      ::

      : "`style-src`"
      ::
        1.  If |policy|'s <a>directive set</a> contains at least one 
            <a>directive</a> whose <a for="directive">name</a> is |name|,
            let |directive| be the first such <a>directive</a>.
            Return |directive|'s <a for="directive">value</a>.

        2.  If |policy|'s <a>directive set</a> contains a
            <a>directive</a> whose <a for="directive">name</a> is 
            "`default-src`", return that <a>directive</a>'s
            <a for="directive">value</a>.

        3.  Return `null`.

      : "`frame-src`"
      ::

      : "`worker-src`"
      ::
        1.  If |policy|'s <a>directive set</a> contains at least one 
            <a>directive</a> whose <a for="directive">name</a> is |name|, 
            let |directive| be the first such <a>directive</a>.
            Return |directive|'s <a for="directive">value</a>.

        2.  If |policy|'s <a>directive set</a> contains a
            <a>directive</a> whose <a for="directive">name</a> is 
            "`child-src`", return that <a>directive</a>'s
            <a for="directive">value</a>.

        3.  If |policy|'s <a>directive set</a> contains a
            <a>directive</a> whose <a for="directive">name</a> is 
            "`default-src`", return that <a>directive</a>'s
            <a for="directive">value</a>.

        4.  Return `null`.

      : "`base-uri`"
      ::

      : "`block-all-mixed-content`"
      ::

      : "`default-src`"
      ::

      : "`frame-ancestors`"
      ::

      : "`form-action`"
      ::

      : "`plugin-types`"
      ::

      : "`report-uri`"
      ::

      : "`require-sri-for`"
      ::

      : "`sandbox`"
      ::

      : "`upgrade-insecure-requests`"
      ::
        1.  If |policy|'s <a>directive set</a> contains at least one 
            <a>directive</a> whose <a for="directive">name</a> is |name|, 
            let |directive| be the first such <a>directive</a>.
            Return |directive|'s <a for="directive">value</a>.

  2.  Return `null`.

  <h4 id="subsume-policy" algorithm>
    Does <a>policy</a> |A| subsume <a>policy</a> |B| given their respective
    <a for="request">origins</a>?
  </h4>

  Given a <a>policy</a> |A| with an <a for="request">origin</a>
  (|origin A|) and a <a>policy</a> |B| with an
  <a for="request">origin</a>  (|origin B|), this algorithm returns "`Subsumes`"
  if |A| <a>subsumes</a> |B|, and returns "`Does Not Subsume`" otherwise.

  1.  If |A|'s <a for="policy">directive set</a> <a for="list">is empty</a>,
      return "`Subsumes`".

  2.  For each |directive A| in |A|'s <a for="policy">directive set</a>:

      1.  Let |directive name| be |directive A|'s <a for="directive">name</a>.

      2.  If |directive name| is "`default-src`", "`report-uri`", "`report-to`",
          <a for="iteration">continue</a>.

      3.  Let |effective directive A| be the result of executing
          [[#effective-directive]] given |directive name| and |A|.

      4.  Let |effective directive B| be the result of executing
          [[#effective-directive]] given |directive name| and |B|.

      5.  If |effective directive A| is `null`, <a for="iteration">continue</a>.

      6.  If |effective directive B| is `null`, return "`Does Not Subsume`".

      7.  If |directive A|'s <a for="directive">name</a> is "`frame-ancestors`":

          1.  ISSUE: TODO.

      8.  If |directive A|'s <a for="directive">name</a> is "`plugin-types`":

          1.  ISSUE: TODO.

      9.  If |directive A|'s <a for="directive">name</a> is "`sandbox`":

          1.  ISSUE: TODO.

      10.  If |directive A|'s <a for="directive">name</a> is "`disown-opener`",
           <a for="iteration">continue</a>.

      11.  Otherwise:

            1.  If the result of executing [[#subsume-source-list]] is 
                "`Does Not Subsume`" given |effective directive A|, |origin A|, 
                |directive name|, |effective directive B|, |origin B|, and 
                |directive name|, return "`Does Not Subsume`".

    3.  Return "`Subsumes`".

  <h3 id="subsume-policy-list" algorithm>
    Does |subsuming policy| subsume |policy list| given their respective
    <a for="/">origins</a>?
  </h3>

  Given a <a>policy</a> |subsuming policy| with an <a for="/">origin</a>
  (|subsuming origin|) and a <a>list</a> of <a>policy</a> objects |policy list|
  with an <a for="/">origin</a>  (|origin|), this algorithm returns "`Subsumes`"
  if |subsuming policy| <a>subsumes</a> |policy list|, and returns
  "`Does Not Subsume`" otherwise.

  <ol class="algorithm">
    1.  If |subsuming policy| is `null`, return "`Subsumes`".

    2.  If |subsuming policy|'s <a for="policy">disposition</a> is "`report`",
        return "`Subsumes`".

    3.  If |subsuming policy|'s <a for="policy">directive set</a>
        <a for="list">is empty</a>, return "`Subsumes`".

    4.  If |policy list| is <a for="list">is empty</a> or `null`, return
        "`Does Not Subsume`".

    5.  Let |effective policy| the result of executing
        [[#intersection-policy-list]] given |policy list| and |origin|.

    6.  Return the result of executing [[#subsume-policy]] given
        |subsuming policy|, |subsuming origin|, |effective policy|, and
        |origin|. 
  </ol>

  <h3 id="required-csp-for-context" algorithm>
    Obtain the required CSP for |context|.
  </h3>

  Given a <a>browsing context</a> (|context|), the following algorithm returns
  its <a>required CSP</a>:

  <ol class="algorithm">
    1.  If |context| is a <a>nested browsing context</a>.

        1.  If |context|'s <a>browsing context container</a> has an <{iframe/csp}>
            content attribute, return its value.

    2.  Return `null`.
  </ol>
</section>

<section>
  Security and Privacy Considerations {#security-and-privacy-considerations}
  =================================== 

  Policy Enforcement {#policy-enforcement}
  ------------------

  Embedded documents should be careful to evaluate the proposed Content Security
  Policy, and not simply to reflect whatever policy an embedder suggests. Doing
  so may enable a clever attacker to selectively disable pieces of a website's
  code which are essential for its own protection.

  In particular, documents which do not expect to be embedded should continue to
  respond to any such request with a Content Security Policy containing an
  appropriate <a>`frame-ancestors`</a> directive.

  Policy Leakage {#policy-leakage}
  --------------

  The enforcement mechanism allows a malicious embedder to read a page's policy
  cross-origin by brute-forcing its constraints. This could leak interesting
  data about the page or the user loading the page if the policy contains secret
  tokens or usernames.

  Again, the best defense here is to control the contexts allowed to embed a
  given resource via an appropriate <a>`frame-ancestors`</a> directive.

  Data Exfiltration {#exfiltration}
  -----------------

  This feature allows an embedder to send information to a third-party endpoint
  via the <a http-header>`Embedding-CSP`</a> HTTP header. This doesn't seem to
  expose any information that couldn't be tunneled in the HTTP request itself
  (via GET parameters, etc), and embedders remain in control over the endpoints
  to which such requests may be made by enforcing a Content Security Policy with
  an appropriate `child-src` directive.
</section>

<!-- Big text: Authoring -->
<section>
  <h2 id="authoring-considerations">Authoring Considerations</h2>

  <h3 id="effect-self">
    The effect of `self` specified in <a>required CSP</a>.
  </h3>

  If <a>required CSP</a> includes `self` in any of the <a>source lists</a>,
  `self` refers to the embedee's <a for="/">origin</a>.

  <div class="example">
    MegaCorp Inc. specifies the following <a>required CSP</a> on their page
    "https://example.com/page.html":

    <pre>
      &lt;iframe src="https://advertisements-r-us.example.com/ad1.cfm"
              <a for="iframe" element-attr>csp</a>="script-src 'self'"&gt;
      &lt;/iframe&gt;
    </pre>

    If the returned CSP is:
    <pre>
     Content-Security-Policy: script-src 'self'
    </pre>

    Then this <{iframe}> element will be loaded. 

    If, however, the returned CSP is:
    <pre>
     Content-Security-Policy: script-src "https://example.com/"
    </pre>

    Then this <{iframe}> element will not be loaded. 
</section>

<section>
  IANA Considerations {#iana}
  ===================

  The permanent message header field registry should be updated
  with the following registration for the
  <a http-header>`Embedding-CSP`</a> header: [[!RFC3864]]

  :   Header field name
  ::  Embedding-CSP
  :   Applicable protocol
  ::  http
  :   Status
  ::  standard
  :   Author/Change controller
  ::  W3C
  :   Specification document
  ::  This specification (See [[#embedding-csp-http-header]])

  Likewise, the registry should be updated with the following registration
  for the <a http-header>`Allow-CSP-From`</a> header: [[!RFC3864]]

  :   Header field name
  ::  Allow-CSP-From
  :   Applicable protocol
  ::  http
  :   Status
  ::  standard
  :   Author/Change controller
  ::  W3C
  :   Specification document
  ::  This specification (See [[#allow-csp-from-http-header]])
</section>
